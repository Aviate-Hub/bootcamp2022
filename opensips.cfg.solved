#
# $Id$
#
# OpenSIPS residential configuration script
#     by OpenSIPS Solutions <team@opensips-solutions.com>
#
# This script was generated via "make menuconfig", from
#   the "Residential" scenario.
# You can enable / disable more features / functionalities by
#   re-generating the scenario with different options.#
#
# Please refer to the Core CookBook at:
#      http://www.opensips.org/Resources/DocsCookbooks
# for a explanation of possible statements, functions and parameters.
#


####### Global Parameters #########

log_level=3
log_stderror=no
log_facility=LOG_LOCAL0

/* uncomment the next line to enable the auto temporary blacklisting of 
   not available destinations (default disabled) */
#disable_dns_blacklist=no

/* uncomment the next line to enable IPv6 lookup after IPv4 dns 
   lookup failures (default disabled) */
#dns_try_ipv6=yes

/* comment the next line to enable the auto discovery of local aliases
   based on revers DNS on IPs */
auto_aliases=no


listen=udp:192.168.0.45:5060   # CUSTOMIZE ME


####### Modules Section ########

#set module path
mpath="/lib/opensips/modules/"

#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

#### Transaction Module
loadmodule "tm.so"
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 30)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

#### Record Route Module
loadmodule "rr.so"
/* do not append from tag to the RR (no need for this script) */
modparam("rr", "append_fromtag", 0)

#### MAX ForWarD module
loadmodule "maxfwd.so"

#### SIP MSG OPerationS module
loadmodule "sipmsgops.so"

#### FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)


#### URI module
loadmodule "uri.so"
modparam("uri", "use_uri_table", 0)


#### MYSQL module
loadmodule "db_mysql.so"

### S1 ###
#### Dialog Module
loadmodule "dialog.so"
modparam("dialog", "profiles_with_value", "caller ; domain")
modparam("dialog", "profiles_no_value", "progress ; active")
modparam("dialog", "db_mode", 2)
modparam("dialog", "db_url",
	"mysql://opensips:opensipsrw@localhost/opensips") # CUSTOMIZE ME
### S1 ###

#### USeR LOCation module
loadmodule "usrloc.so"
modparam("usrloc", "nat_bflag", "NAT")
modparam("usrloc", "db_mode",   2)
modparam("usrloc", "db_url",
	"mysql://opensips:opensipsrw@localhost/opensips") # CUSTOMIZE ME


#### REGISTRAR module
loadmodule "registrar.so"
modparam("registrar", "tcp_persistent_flag", "TCP_PERSISTENT")

/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)

#### ACCounting module
loadmodule "acc.so"
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_cancels", 0)
/* by default we do not adjust the direct of the sequential requests.
   if you enable this parameter, be sure the enable "append_fromtag"
   in "rr" module */
modparam("acc", "detect_direction", 0)


#### AUTHentication modules
loadmodule "auth.so"
loadmodule "auth_db.so"
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db|uri", "db_url",
	"mysql://opensips:opensipsrw@localhost/opensips") # CUSTOMIZE ME


#### Domain Module
loadmodule "domain.so"
modparam("domain", "db_url",
	"mysql://opensips:opensipsrw@localhost/opensips")
modparam("domain", "db_mode", 1)   # Use caching
modparam("uri|auth_db|usrloc", "use_domain", 1)

loadmodule "alias_db.so"

# ----- alias_db params -----
modparam("alias_db", "db_url",
	"mysql://opensips:opensipsrw@localhost/opensips")

loadmodule "cachedb_local.so"

modparam("auth","username_spec","$avp(userspec)")
modparam("auth","password_spec","$avp(passwd)")
modparam("auth","calculate_ha1",1)

loadmodule "permissions.so"
loadmodule "group.so"

# ----- permissions params ----
modparam("permissions", "db_url",
	"mysql://opensips:opensipsrw@localhost/opensips")
modparam("group", "db_url",
	"mysql://opensips:opensipsrw@localhost/opensips")

loadmodule "drouting.so"

# ----- drouting params -----
modparam("drouting", "use_domain", 0)
modparam("drouting","db_url", "mysql://opensips:opensipsrw@localhost/opensips")

# ----- tm params -----
modparam("tm", "fr_timeout", 3)
modparam("tm", "fr_inv_timeout", 20)

loadmodule "avpops.so"
loadmodule "dialplan.so"

#------ avpops params -----
modparam("avpops", "db_url", "mysql://opensips:opensipsrw@localhost/opensips")
modparam("avpops", "avp_table", "usr_preferences")

#------ load the dpid field to a pseudo-variable $avp(dpid) ------
modparam("auth_db", "load_credentials", "$avp(rpid)=rpid ;$avp(dpid)= dpid;$avp(passwd)=password")
modparam("dialplan", "db_url","mysql://opensips:opensipsrw@localhost/opensips")
## attribute of the matched line will be store in the $avp(dest) 


loadmodule "proto_udp.so"

####### Routing Logic ########

# main request routing logic

route{
	

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if (has_totag()) {
		# sequential request withing a dialog should
		# take the path determined by record-routing
		if (loose_route()) {
			if(is_present_hf("Authorization")) consume_credentials();
			
			if (is_method("INVITE")) {
				# even if in most of the cases is useless, do RR for
				# re-INVITEs alos, as some buggy clients do change route set
				# during the dialog.
				record_route();
			}

			

			# route it out to whatever destination was set by loose_route()
			# in $du (destination URI).
			route(relay);
		} else {
			
			if ( is_method("ACK") ) {
				if ( t_check_trans() ) {
					# non loose-route, but stateful ACK; must be an ACK after 
					# a 487 or e.g. 404 from upstream server
					t_relay();
					exit;
				} else {
					# ACK without matching transaction ->
					# ignore and discard
					exit;
				}
			}
			sl_send_reply("404","Not here");
		}
		exit;
	}

	# CANCEL processing
	if (is_method("CANCEL"))
	{
		if (t_check_trans())
			t_relay();
		exit;
	}

	t_check_trans();

	if ( !(is_method("REGISTER")  ) ) {
		
		if(is_from_local())		
		{
			
			# authenticate if from local subscriber
			# authenticate all initial non-REGISTER request that pretend to be
			# generated by local subscriber (domain from FROM URI is local)
			if(!check_source_address("0")){
				if (!proxy_authorize("", "subscriber")) {
					proxy_challenge("", "0");
					exit;
			   	}
				if (!db_check_from()) {
					sl_send_reply("403","Forbidden auth ID");
					exit;
				}
			}

			consume_credentials();
			# caller authenticated
			
		} else {
			# if caller is not local, then called number must be local
			
			if (!uri==myself) {
				send_reply("403","Rely forbidden");
				exit;
			}
		}

	}

	### S2 ###
	### Create a new dialog ###
	create_dialog();

	### Set profile ###
	if(is_method("INVITE")) {
		if($DLG_status!=NULL) {
			set_dlg_profile("caller","$fU@$fd");
			set_dlg_profile("domain","$fd");
		}

		#Counter for  calls from this caller
		$var(ccaller)=0;
		#counter for calls from this domain
		$var(cdomain)=0;	

		get_profile_size("caller","$fU@$fd","$var(ccaller)");
		get_profile_size("caller","$fd","$var(cdomain)");
		xlog("L_INFO", "Number of calls from user $fU@$fd is $var(ccaller)");
		xlog("L_INFO", "Number of calls from domain $fd is $var(cdomain)");

	}
	### S2 ###


	# preloaded route checking
	if (loose_route()) {
		xlog("L_ERR",
		"Attempt to route with preloaded Route's [$fu/$tu/$ru/$ci]");
		if (!is_method("ACK"))
			sl_send_reply("403","Preload Route denied");
		exit;
	}

	# record routing
	if (!is_method("REGISTER|MESSAGE"))
		record_route();

	if (!is_uri_host_local()) {
		append_hf("P-hint: outbound\r\n"); 
		
		route(relay);
	}


	# requests for my domain
	
	if (is_method("PUBLISH|SUBSCRIBE"))
	{
		sl_send_reply("503", "Service Unavailable");
		exit;
	}

	if (is_method("REGISTER"))
	{
		### Caching for registration passwords ###
		# do we have the password cached ?
		if(cache_fetch("local","passwd_$tu",$avp(passwd))) {
		        $avp(userspec) = $tU;
		        xlog("SCRIPT: stored password is $avp(passwd)\n");
		        # perform auth from variables
		        # $avp(userspec) contains the username
		        # $avp(passwd) contains the password
		        if (!pv_www_authorize("")) {
	                	# authentication failed -> do challenge
		                www_challenge("", "0");
		                exit;
	        	};
		} else {
		        # perform DB authentication ->
		        # password will be loaded from DB automatically
		        if (!www_authorize("", "subscriber")) {
				# authentication failed -> do challenge
		                 www_challenge("", "0");
		                 exit;
			};
		        # after DB authentication, the password is available
		        # in $avp(passwd) because of the "load_credentials"
		        # module parameter.
		        xlog("SCRIPT: storing password <$avp(passwd)>\n");
		        # use a 20 minutes lifetime for the password;
		        # after that, it will erased from cache and we do
		        # db authentication again (refresh the passwd from DB)
		        cache_store("local","passwd_$tu","$avp(passwd)",1200);
		}

		# authenticate the REGISTER requests
		#if (!www_authorize("", "subscriber"))
		#{
		#	www_challenge("", "0");
		#	exit;
		#}
		
		if (!db_check_to()) 
		{
			sl_send_reply("403","Forbidden auth ID");
			exit;
		}

		if (   0 ) setflag(TCP_PERSISTENT);

		

		if (!save("location"))
			sl_reply_error();

		exit;
	}

	if ($rU==NULL) {
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}

	if(avp_db_load("$ru","$avp(callfwd)")) {
	     $ru=$avp(callfwd);
	     xlog("forwarded to: $avp(callfwd)");
	}

	# Dial plan processing
	if( !is_avp_set("$avp(dpid)") ) {
		$avp(dpid)=0;
	}

	if(!dp_translate("$avp(dpid)","$ruri.user/$ruri.user","$avp(dest)")) {
		sl_send_reply("420", "Invalid Extension");
		exit;
	}
	xlog("Dialplan: Subscriber.s dpid: $(avp(dpid))");
	xlog("Dialplan: Destination: $avp(dest)");

	if ($avp(dest)=="3") {
		#Route to usrloc
		route(usrloc);
	}

	if ($avp(dest)=="4") {
		#route to drouting
		route(pstn);
	}

	if ($avp(dest)=="5") {
		#route to media server
		route(media);	
	}
	sl_send_reply("420", "Invalid Extension");
	exit;

	alias_db_lookup("dbaliases");

	# do lookup with method filtering
	if (!lookup("location","m")) {
		if (!db_does_uri_exist()) {
			send_reply("420","Bad Extension");
			exit;
		}
		
		t_newtran();
		t_reply("404", "Not Found");
		exit;
	} 

	# when routing via usrloc, log the missed calls also
	setflag(ACC_MISSED);
	route(relay);
}


route[pstn] {
    xlog("routed using drouting");
    # routing to the pstn
    if(!do_routing("0")) {
	     sl_send_reply("500", "No routes available");
	     exit;
    }
    ## for INVITEs enable some additional helper routes
    if (is_method("INVITE")) {
		t_on_branch("per_branch_ops");
		t_on_reply("handle_nat");
		t_on_failure("gateway_fail");
    }

    if (!t_relay()) {
		sl_reply_error();
    }
    exit;
}


route[relay] {
	# for INVITEs enable some additional helper routes
	if (is_method("INVITE")) {
		t_on_branch("per_branch_ops");
		t_on_reply("handle_nat");
		t_on_failure("missed_call");
	}

	

	if (!t_relay()) {
		send_reply("500","Internal Error");
	};
	exit;
}


route[usrloc]{
	if (!lookup("location")) {
		switch ($retcode) {
			case -1:
			case -3:
				t_newtran();
				t_reply("404", "Not Found");
				exit;
			case -2:
				sl_send_reply("405", "Method Not Allowed");
				exit;
		}
	}
	# when routing via usrloc, log the missed calls also
	setflag(2);
	route(relay);
}

route[media] {
	rewritehostport("192.168.11.137:5061");
	route(relay);
}



branch_route[per_branch_ops] {
	xlog("new branch at $ru\n");
}


onreply_route[handle_nat] {
	### S3 ###
	if($DLG_status!=NULL && is_method("INVITE")) {
		if($rs=~"18[0-9]") {
			set_dlg_profile("progress");
		} else {
			if(is_in_profile("progress")) unset_dlg_profile("progress");
		}
		if($rs=~"2[0-9][0-9]") {
			set_dlg_profile("active");
		} else {
			if(is_in_profile("active")) unset_dlg_profile("active");
		}
	}
	
	if(is_method("INVITE")) {
		#Active Call Counter
		$var(cactive)=0;
		#In Progress Call Counter
		$var(cprogress)=0;
		get_profile_size("active","$var(cactive)");
		get_profile_size("progress","$var(cprogress)");
		xlog("L_INFO","There are $var(cactive) active calls and $var(cprogress) calls in progress");
	} 	
	### S3 ###
	
}

failure_route[missed_call] {
	if (t_was_cancelled()) {
		exit;
	}

	# uncomment the following lines if you want to block client 
	# redirect based on 3xx replies.
	##if (t_check_status("3[0-9][0-9]")) {
	##t_reply("404","Not found");
	##	exit;
	##}

	##--
	##-- If busy send to the e-mail server, prefix the "b"
	##-- character to indicate busy. 
	##--
	if (t_check_status("486")) {
        	revert_uri();
	        prefix("b"); #This prefix is included to play the busy message
        	xlog("L_ERR","> 486 ruri=<$ru>");
	        route(media);
     		route(relay);
	        exit;
	}
	##--
	##-- If timeout (408) or unavailable temporarily (480),
	##-- prefix the uri with the "u"character to indicate 
	##-- unanswered and send to the e-mail
	##-- sever
	##--
	if (t_check_status("408") || t_check_status("480")) {
		revert_uri();
		prefix("u");#This prefix is included to play the unanswered message
		xlog("L_ERR","> 480 ruri=<$ru>");
		route(media);
		route(relay);
		exit;
	}
}

failure_route[gateway_fail] {
	if (t_was_cancelled()) {
   		exit;
	}

	xlog("failure route 2\n");
	if (t_check_status("(408)|(5[0-9][0-9])")){
	if (use_next_gw()) {
		    xlog ("next gateway $ru \n");
		    t_on_failure("gateway_fail");
		    t_relay();
   		    exit;
		}
	       t_reply("503", "Service not available, no more gateways");
          exit;
	}
}



